package straighline.test;

/**
 *
 * @author Christopher Brantley <ccbrantley@uncg.edu>
 */
public class Buchheim {
    private double WIDTH_GAP = 20;
    private double HEIGHT_GAP = 0;
    public void execute (Node _node) {
        this.firstWalk(_node);
        double min = this.secondWalk(_node, 0, _node.getHeight(), Double.MAX_VALUE);
        if (min < 0)
            this.thirdWalk(_node, -min);
    }

    private Node firstWalk (Node _node) {
        if (_node.getChildren().isEmpty()) {
            if (_node.getLeftMostSibling() != null) {
                //System.out.println("firstWalk, if, if: " + _node.getText());
                _node.setX(_node.getLeftSibling().getX() + _node.getLeftSibling().getWidth() + this.WIDTH_GAP);
            }
            else {
                //System.out.println("firstWalk, if, else: " + _node.getText());
                _node.setX(0);
            }
        }
        else {
            Node defaultAncestor = _node.getChildren().get(0);
            for (Node node : _node.getChildren()) {
                this.firstWalk(node);
                defaultAncestor = this.apportion(node, defaultAncestor);
            }
            this.executeShifts(_node);
            double midPoint = (_node.getFirstChild().getX() + _node.getLastChild().getX() + _node.getLastChild().getWidth()) / 2;
            Node ell = _node.getFirstChild();
            Node arr = _node.getLastChild();
            Node leftSibling = _node.getLeftSibling();
            if (leftSibling!= null) {
                //System.out.println("firstWalk, else, if: " + _node.getText());
                _node.setX(midPoint - (_node.getWidth()) / 2);
                _node.setMod(_node.getX() + (_node.getWidth() /2) - midPoint);
            }
            else {
                //System.out.println("firstWalk, else, else: " + _node.getText());
                _node.setX(midPoint - (_node.getWidth()) / 2);

            }
        }
        return _node;
    }

    private double secondWalk (Node _node, double _m, double _depth, double _min) {
        _node.setX(_node.getX() + _m);
        _node.setY(_depth);
        if (_node.getX() < _min)
            _min = _node.getX();
        for (Node node : _node.getChildren()) {
            _min = this.secondWalk(node, _m + _node.getMod(), _depth + _node.getHeight(), _min);
        }
        return _min;
    }

    private void thirdWalk (Node _node, double _n) {
        System.out.println("thirdWalk, _n: " + _node);
        _node.setX(_node.getX() + _n);
        _node.getChildren().forEach(child -> {
            this.thirdWalk(child, _n);
        });
    }

    private void executeShifts (Node _node) {
        double shift = 0;
        double change = 0;
        Node child;
        for (int i = _node.getChildren().size() - 1; i >= 0; i--) {
            child = _node.getChildren().get(i);
            child.setX(child.getX() + shift);
            child.setMod(child.getMod() + shift);
            change += child.getChange();
            shift += child.getShift() + change;
        }
    }

    private Node ancestor (Node _vil, Node _v, Node _defaultAncestor) {
        if (_v.getParent().getChildren().contains(_vil.getAncestor()))
            return _vil.getAncestor();
        else
            return _defaultAncestor;
    }

    private void moveSubtrees (Node _left, Node _right, double _shift) {
        double subtrees = _right.getNumber() - _left.getNumber();
        double result;
        if (subtrees == 0)
            result = 0;
        else
            result = _shift / subtrees;
        System.out.println(_left.getText() + " is conflicted with " + _right.getText() + ", shift = " + _shift + ", subtrees = " + subtrees);
        _right.setChange(_right.getChange() - result);
        _right.setShift(_right.getShift() + _shift);
        _left.setChange(_left.getChange() + result);
        _right.setX(_right.getX() + _shift);
        _right.setMod(_right.getMod() + _shift);
        _right.getParent().setChange(_right.getParent().getChange() - result);
        _right.getParent().setShift(_right.getParent().getShift() + _shift);
        _right.getParent().setMod(_right.getParent().getMod() + _shift);
        _left.getParent().setChange( _left.getParent().getChange() + result);
    }



    private Node apportion (Node _node, Node _defaultAncestor) {
        System.out.println("apportion _node, " + _node.getText());
        Node leftBrother = _node.getLeftSibling();
        if (leftBrother != null) {
            Node vir = _node;
            Node vor = _node;
            Node vil = leftBrother;
            Node vol = _node.getLeftMostSibling();
            double sir = _node.getMod();
            double sor = _node.getMod();
            double sil = vil.getMod();
            double sol = vol.getMod();
            while (vil.getNextRight()!= null && vir.getNextLeft() != null) {
                vil = vil.getNextRight();
                vir = vir.getNextLeft();
                vol = vol.getNextLeft();
                vor = vor.getNextRight();
                vor.setAncestor(_node);
                double shift = (vil.getX() + sil + vil.getWidth()) - (vir.getX() + sir);
                if (shift > 0) {
                    this.moveSubtrees(this.ancestor(vil, _node, _defaultAncestor), _node, shift);
                    sir = sir + shift;
                    sor = sor + shift;
                }
                sil += vil.getMod();
                sir += vir.getMod();
                sol += vol.getMod();
                sor += vor.getMod();
            }
            if (vil.getNextRight() != null && vor.getRightMostSibling() == null) {
                vor.setThread(vil.getNextRight());
                vor.setMod(vor.getMod() + (sir - sol));
            }
            else {
                if (vir.getNextLeft() != null && vol.getNextLeft() == null) {
                    vol.setThread(vir.getNextLeft());
                    vol.setMod(vol.getMod() + (sir - sol));
                }
                _defaultAncestor = _node;
            }

        }
        return _defaultAncestor;
    }
}